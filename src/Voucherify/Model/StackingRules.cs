/*
 * Voucherify API
 *
 * Voucherify promotion engine REST API. Please see https://docs.voucherify.io/docs for more details.
 *
 * The version of the OpenAPI document: v2018-08-01
 * Contact: support@voucherify.io
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Runtime.Serialization;
using System.Text;
using System.Text.RegularExpressions;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Linq;
using System.ComponentModel.DataAnnotations;
using OpenAPIDateConverter = Voucherify.Client.OpenAPIDateConverter;

namespace Voucherify.Model
{
    /// <summary>
    /// Defines stacking rules for redeemables. Read more in the [Stacking Rule Documentation](https://support.voucherify.io/article/604-stacking-rules).
    /// </summary>
    [DataContract(Name = "StackingRules")]
    public partial class StackingRules : IValidatableObject
    {
        /// <summary>
        /// Defines redeemables application mode.
        /// </summary>
        /// <value>Defines redeemables application mode.</value>
        [JsonConverter(typeof(StringEnumConverter))]
        public enum RedeemablesApplicationModeEnum
        {
            /// <summary>
            /// Enum ALL for value: ALL
            /// </summary>
            [EnumMember(Value = "ALL")]
            ALL = 1,

            /// <summary>
            /// Enum PARTIAL for value: PARTIAL
            /// </summary>
            [EnumMember(Value = "PARTIAL")]
            PARTIAL = 2
        }


        /// <summary>
        /// Defines redeemables application mode.
        /// </summary>
        /// <value>Defines redeemables application mode.</value>

        [DataMember(Name = "redeemables_application_mode", EmitDefaultValue = true)]
        public RedeemablesApplicationModeEnum? RedeemablesApplicationMode
        {
            get{ return _RedeemablesApplicationMode;}
            set
            {
                _RedeemablesApplicationMode = value;
                _flagRedeemablesApplicationMode = true;
            }
        }
        private RedeemablesApplicationModeEnum? _RedeemablesApplicationMode;
        private bool _flagRedeemablesApplicationMode;

        /// <summary>
        /// Returns false as RedeemablesApplicationMode should not be serialized given that it's read-only.
        /// </summary>
        /// <returns>false (boolean)</returns>
        public bool ShouldSerializeRedeemablesApplicationMode()
        {
            return _flagRedeemablesApplicationMode;
        }
        /// <summary>
        /// Defines redeemables sorting rule.
        /// </summary>
        /// <value>Defines redeemables sorting rule.</value>
        [JsonConverter(typeof(StringEnumConverter))]
        public enum RedeemablesSortingRuleEnum
        {
            /// <summary>
            /// Enum CATEGORYHIERARCHY for value: CATEGORY_HIERARCHY
            /// </summary>
            [EnumMember(Value = "CATEGORY_HIERARCHY")]
            CATEGORYHIERARCHY = 1,

            /// <summary>
            /// Enum REQUESTEDORDER for value: REQUESTED_ORDER
            /// </summary>
            [EnumMember(Value = "REQUESTED_ORDER")]
            REQUESTEDORDER = 2
        }


        /// <summary>
        /// Defines redeemables sorting rule.
        /// </summary>
        /// <value>Defines redeemables sorting rule.</value>

        [DataMember(Name = "redeemables_sorting_rule", EmitDefaultValue = true)]
        public RedeemablesSortingRuleEnum? RedeemablesSortingRule
        {
            get{ return _RedeemablesSortingRule;}
            set
            {
                _RedeemablesSortingRule = value;
                _flagRedeemablesSortingRule = true;
            }
        }
        private RedeemablesSortingRuleEnum? _RedeemablesSortingRule;
        private bool _flagRedeemablesSortingRule;

        /// <summary>
        /// Returns false as RedeemablesSortingRule should not be serialized given that it's read-only.
        /// </summary>
        /// <returns>false (boolean)</returns>
        public bool ShouldSerializeRedeemablesSortingRule()
        {
            return _flagRedeemablesSortingRule;
        }
        /// <summary>
        /// Defines redeemables products application mode.
        /// </summary>
        /// <value>Defines redeemables products application mode.</value>
        [JsonConverter(typeof(StringEnumConverter))]
        public enum RedeemablesProductsApplicationModeEnum
        {
            /// <summary>
            /// Enum STACK for value: STACK
            /// </summary>
            [EnumMember(Value = "STACK")]
            STACK = 1,

            /// <summary>
            /// Enum ONCE for value: ONCE
            /// </summary>
            [EnumMember(Value = "ONCE")]
            ONCE = 2
        }


        /// <summary>
        /// Defines redeemables products application mode.
        /// </summary>
        /// <value>Defines redeemables products application mode.</value>

        [DataMember(Name = "redeemables_products_application_mode", EmitDefaultValue = true)]
        public RedeemablesProductsApplicationModeEnum? RedeemablesProductsApplicationMode
        {
            get{ return _RedeemablesProductsApplicationMode;}
            set
            {
                _RedeemablesProductsApplicationMode = value;
                _flagRedeemablesProductsApplicationMode = true;
            }
        }
        private RedeemablesProductsApplicationModeEnum? _RedeemablesProductsApplicationMode;
        private bool _flagRedeemablesProductsApplicationMode;

        /// <summary>
        /// Returns false as RedeemablesProductsApplicationMode should not be serialized given that it's read-only.
        /// </summary>
        /// <returns>false (boolean)</returns>
        public bool ShouldSerializeRedeemablesProductsApplicationMode()
        {
            return _flagRedeemablesProductsApplicationMode;
        }
        /// <summary>
        /// Defines redeemables no effect rule.
        /// </summary>
        /// <value>Defines redeemables no effect rule.</value>
        [JsonConverter(typeof(StringEnumConverter))]
        public enum RedeemablesNoEffectRuleEnum
        {
            /// <summary>
            /// Enum REDEEMANYWAY for value: REDEEM_ANYWAY
            /// </summary>
            [EnumMember(Value = "REDEEM_ANYWAY")]
            REDEEMANYWAY = 1,

            /// <summary>
            /// Enum SKIP for value: SKIP
            /// </summary>
            [EnumMember(Value = "SKIP")]
            SKIP = 2
        }


        /// <summary>
        /// Defines redeemables no effect rule.
        /// </summary>
        /// <value>Defines redeemables no effect rule.</value>

        [DataMember(Name = "redeemables_no_effect_rule", EmitDefaultValue = true)]
        public RedeemablesNoEffectRuleEnum? RedeemablesNoEffectRule
        {
            get{ return _RedeemablesNoEffectRule;}
            set
            {
                _RedeemablesNoEffectRule = value;
                _flagRedeemablesNoEffectRule = true;
            }
        }
        private RedeemablesNoEffectRuleEnum? _RedeemablesNoEffectRule;
        private bool _flagRedeemablesNoEffectRule;

        /// <summary>
        /// Returns false as RedeemablesNoEffectRule should not be serialized given that it's read-only.
        /// </summary>
        /// <returns>false (boolean)</returns>
        public bool ShouldSerializeRedeemablesNoEffectRule()
        {
            return _flagRedeemablesNoEffectRule;
        }
        /// <summary>
        /// Defines the rollback mode for the order. &#x60;WITH_ORDER&#x60; is a default setting. The redemption is rolled back together with the data about the order, including related discount values. &#x60;WITHOUT_ORDER&#x60; allows rolling the redemption back without affecting order data.
        /// </summary>
        /// <value>Defines the rollback mode for the order. &#x60;WITH_ORDER&#x60; is a default setting. The redemption is rolled back together with the data about the order, including related discount values. &#x60;WITHOUT_ORDER&#x60; allows rolling the redemption back without affecting order data.</value>
        [JsonConverter(typeof(StringEnumConverter))]
        public enum RedeemablesRollbackOrderModeEnum
        {
            /// <summary>
            /// Enum WITHORDER for value: WITH_ORDER
            /// </summary>
            [EnumMember(Value = "WITH_ORDER")]
            WITHORDER = 1,

            /// <summary>
            /// Enum WITHOUTORDER for value: WITHOUT_ORDER
            /// </summary>
            [EnumMember(Value = "WITHOUT_ORDER")]
            WITHOUTORDER = 2
        }


        /// <summary>
        /// Defines the rollback mode for the order. &#x60;WITH_ORDER&#x60; is a default setting. The redemption is rolled back together with the data about the order, including related discount values. &#x60;WITHOUT_ORDER&#x60; allows rolling the redemption back without affecting order data.
        /// </summary>
        /// <value>Defines the rollback mode for the order. &#x60;WITH_ORDER&#x60; is a default setting. The redemption is rolled back together with the data about the order, including related discount values. &#x60;WITHOUT_ORDER&#x60; allows rolling the redemption back without affecting order data.</value>

        [DataMember(Name = "redeemables_rollback_order_mode", EmitDefaultValue = true)]
        public RedeemablesRollbackOrderModeEnum? RedeemablesRollbackOrderMode
        {
            get{ return _RedeemablesRollbackOrderMode;}
            set
            {
                _RedeemablesRollbackOrderMode = value;
                _flagRedeemablesRollbackOrderMode = true;
            }
        }
        private RedeemablesRollbackOrderModeEnum? _RedeemablesRollbackOrderMode;
        private bool _flagRedeemablesRollbackOrderMode;

        /// <summary>
        /// Returns false as RedeemablesRollbackOrderMode should not be serialized given that it's read-only.
        /// </summary>
        /// <returns>false (boolean)</returns>
        public bool ShouldSerializeRedeemablesRollbackOrderMode()
        {
            return _flagRedeemablesRollbackOrderMode;
        }
        /// <summary>
        /// Initializes a new instance of the <see cref="StackingRules" /> class.
        /// </summary>
        /// <param name="redeemablesLimit">Defines how many redeemables can be sent in one stacking request (note: more redeemables means more processing time!). (default to 30).</param>
        /// <param name="applicableRedeemablesLimit">Defines how many of the sent redeemables will be applied to the order. For example, a user can select 30 discounts but only 5 will be applied to the order and the remaining will be labelled as SKIPPED. (default to 5).</param>
        /// <param name="applicableRedeemablesPerCategoryLimit">Defines how many redeemables per category can be applied in one request. (default to 1).</param>
        /// <param name="applicableExclusiveRedeemablesLimit">Defines how many redeemables with an exclusive category can be applied in one request. (default to 1).</param>
        /// <param name="applicableExclusiveRedeemablesPerCategoryLimit">Defines how many redeemables with an exclusive category per category in stacking rules can be applied in one request. (default to 1).</param>
        /// <param name="exclusiveCategories">Lists all exclusive categories. A redeemable from a campaign with an exclusive category is the only redeemable to be redeemed when applied with redeemables from other campaigns unless these campaigns are exclusive or joint..</param>
        /// <param name="jointCategories">Lists all joint categories. A campaign with a joint category is always applied regardless of the exclusivity of other campaigns..</param>
        /// <param name="redeemablesApplicationMode">Defines redeemables application mode..</param>
        /// <param name="redeemablesSortingRule">Defines redeemables sorting rule. (default to RedeemablesSortingRuleEnum.REQUESTEDORDER).</param>
        /// <param name="redeemablesProductsApplicationMode">Defines redeemables products application mode..</param>
        /// <param name="redeemablesNoEffectRule">Defines redeemables no effect rule..</param>
        /// <param name="redeemablesRollbackOrderMode">Defines the rollback mode for the order. &#x60;WITH_ORDER&#x60; is a default setting. The redemption is rolled back together with the data about the order, including related discount values. &#x60;WITHOUT_ORDER&#x60; allows rolling the redemption back without affecting order data..</param>
        public StackingRules(int? redeemablesLimit = 30, int? applicableRedeemablesLimit = 5, int? applicableRedeemablesPerCategoryLimit = 1, int? applicableExclusiveRedeemablesLimit = 1, int? applicableExclusiveRedeemablesPerCategoryLimit = 1, List<string> exclusiveCategories = default(List<string>), List<string> jointCategories = default(List<string>), RedeemablesApplicationModeEnum? redeemablesApplicationMode = default(RedeemablesApplicationModeEnum?), RedeemablesSortingRuleEnum? redeemablesSortingRule = RedeemablesSortingRuleEnum.REQUESTEDORDER, RedeemablesProductsApplicationModeEnum? redeemablesProductsApplicationMode = default(RedeemablesProductsApplicationModeEnum?), RedeemablesNoEffectRuleEnum? redeemablesNoEffectRule = default(RedeemablesNoEffectRuleEnum?), RedeemablesRollbackOrderModeEnum? redeemablesRollbackOrderMode = default(RedeemablesRollbackOrderModeEnum?))
        {
            this._ExclusiveCategories = exclusiveCategories;
            if (this.ExclusiveCategories != null)
            {
                this._flagExclusiveCategories = true;
            }
            this._JointCategories = jointCategories;
            if (this.JointCategories != null)
            {
                this._flagJointCategories = true;
            }
            this._RedeemablesApplicationMode = redeemablesApplicationMode;
            if (this.RedeemablesApplicationMode != null)
            {
                this._flagRedeemablesApplicationMode = true;
            }
            this._RedeemablesProductsApplicationMode = redeemablesProductsApplicationMode;
            if (this.RedeemablesProductsApplicationMode != null)
            {
                this._flagRedeemablesProductsApplicationMode = true;
            }
            this._RedeemablesNoEffectRule = redeemablesNoEffectRule;
            if (this.RedeemablesNoEffectRule != null)
            {
                this._flagRedeemablesNoEffectRule = true;
            }
            this._RedeemablesRollbackOrderMode = redeemablesRollbackOrderMode;
            if (this.RedeemablesRollbackOrderMode != null)
            {
                this._flagRedeemablesRollbackOrderMode = true;
            }
        }

        /// <summary>
        /// Defines how many redeemables can be sent in one stacking request (note: more redeemables means more processing time!).
        /// </summary>
        /// <value>Defines how many redeemables can be sent in one stacking request (note: more redeemables means more processing time!).</value>
        [DataMember(Name = "redeemables_limit", EmitDefaultValue = true)]
        public int? RedeemablesLimit
        {
            get{ return _RedeemablesLimit;}
            set
            {
                _RedeemablesLimit = value;
                _flagRedeemablesLimit = true;
            }
        }
        private int? _RedeemablesLimit;
        private bool _flagRedeemablesLimit;

        /// <summary>
        /// Returns false as RedeemablesLimit should not be serialized given that it's read-only.
        /// </summary>
        /// <returns>false (boolean)</returns>
        public bool ShouldSerializeRedeemablesLimit()
        {
            return _flagRedeemablesLimit;
        }
        /// <summary>
        /// Defines how many of the sent redeemables will be applied to the order. For example, a user can select 30 discounts but only 5 will be applied to the order and the remaining will be labelled as SKIPPED.
        /// </summary>
        /// <value>Defines how many of the sent redeemables will be applied to the order. For example, a user can select 30 discounts but only 5 will be applied to the order and the remaining will be labelled as SKIPPED.</value>
        [DataMember(Name = "applicable_redeemables_limit", EmitDefaultValue = true)]
        public int? ApplicableRedeemablesLimit
        {
            get{ return _ApplicableRedeemablesLimit;}
            set
            {
                _ApplicableRedeemablesLimit = value;
                _flagApplicableRedeemablesLimit = true;
            }
        }
        private int? _ApplicableRedeemablesLimit;
        private bool _flagApplicableRedeemablesLimit;

        /// <summary>
        /// Returns false as ApplicableRedeemablesLimit should not be serialized given that it's read-only.
        /// </summary>
        /// <returns>false (boolean)</returns>
        public bool ShouldSerializeApplicableRedeemablesLimit()
        {
            return _flagApplicableRedeemablesLimit;
        }
        /// <summary>
        /// Defines how many redeemables per category can be applied in one request.
        /// </summary>
        /// <value>Defines how many redeemables per category can be applied in one request.</value>
        [DataMember(Name = "applicable_redeemables_per_category_limit", EmitDefaultValue = true)]
        public int? ApplicableRedeemablesPerCategoryLimit
        {
            get{ return _ApplicableRedeemablesPerCategoryLimit;}
            set
            {
                _ApplicableRedeemablesPerCategoryLimit = value;
                _flagApplicableRedeemablesPerCategoryLimit = true;
            }
        }
        private int? _ApplicableRedeemablesPerCategoryLimit;
        private bool _flagApplicableRedeemablesPerCategoryLimit;

        /// <summary>
        /// Returns false as ApplicableRedeemablesPerCategoryLimit should not be serialized given that it's read-only.
        /// </summary>
        /// <returns>false (boolean)</returns>
        public bool ShouldSerializeApplicableRedeemablesPerCategoryLimit()
        {
            return _flagApplicableRedeemablesPerCategoryLimit;
        }
        /// <summary>
        /// Defines how many redeemables with an exclusive category can be applied in one request.
        /// </summary>
        /// <value>Defines how many redeemables with an exclusive category can be applied in one request.</value>
        [DataMember(Name = "applicable_exclusive_redeemables_limit", EmitDefaultValue = true)]
        public int? ApplicableExclusiveRedeemablesLimit
        {
            get{ return _ApplicableExclusiveRedeemablesLimit;}
            set
            {
                _ApplicableExclusiveRedeemablesLimit = value;
                _flagApplicableExclusiveRedeemablesLimit = true;
            }
        }
        private int? _ApplicableExclusiveRedeemablesLimit;
        private bool _flagApplicableExclusiveRedeemablesLimit;

        /// <summary>
        /// Returns false as ApplicableExclusiveRedeemablesLimit should not be serialized given that it's read-only.
        /// </summary>
        /// <returns>false (boolean)</returns>
        public bool ShouldSerializeApplicableExclusiveRedeemablesLimit()
        {
            return _flagApplicableExclusiveRedeemablesLimit;
        }
        /// <summary>
        /// Defines how many redeemables with an exclusive category per category in stacking rules can be applied in one request.
        /// </summary>
        /// <value>Defines how many redeemables with an exclusive category per category in stacking rules can be applied in one request.</value>
        [DataMember(Name = "applicable_exclusive_redeemables_per_category_limit", EmitDefaultValue = true)]
        public int? ApplicableExclusiveRedeemablesPerCategoryLimit
        {
            get{ return _ApplicableExclusiveRedeemablesPerCategoryLimit;}
            set
            {
                _ApplicableExclusiveRedeemablesPerCategoryLimit = value;
                _flagApplicableExclusiveRedeemablesPerCategoryLimit = true;
            }
        }
        private int? _ApplicableExclusiveRedeemablesPerCategoryLimit;
        private bool _flagApplicableExclusiveRedeemablesPerCategoryLimit;

        /// <summary>
        /// Returns false as ApplicableExclusiveRedeemablesPerCategoryLimit should not be serialized given that it's read-only.
        /// </summary>
        /// <returns>false (boolean)</returns>
        public bool ShouldSerializeApplicableExclusiveRedeemablesPerCategoryLimit()
        {
            return _flagApplicableExclusiveRedeemablesPerCategoryLimit;
        }
        /// <summary>
        /// Lists all exclusive categories. A redeemable from a campaign with an exclusive category is the only redeemable to be redeemed when applied with redeemables from other campaigns unless these campaigns are exclusive or joint.
        /// </summary>
        /// <value>Lists all exclusive categories. A redeemable from a campaign with an exclusive category is the only redeemable to be redeemed when applied with redeemables from other campaigns unless these campaigns are exclusive or joint.</value>
        [DataMember(Name = "exclusive_categories", EmitDefaultValue = true)]
        public List<string> ExclusiveCategories
        {
            get{ return _ExclusiveCategories;}
            set
            {
                _ExclusiveCategories = value;
                _flagExclusiveCategories = true;
            }
        }
        private List<string> _ExclusiveCategories;
        private bool _flagExclusiveCategories;

        /// <summary>
        /// Returns false as ExclusiveCategories should not be serialized given that it's read-only.
        /// </summary>
        /// <returns>false (boolean)</returns>
        public bool ShouldSerializeExclusiveCategories()
        {
            return _flagExclusiveCategories;
        }
        /// <summary>
        /// Lists all joint categories. A campaign with a joint category is always applied regardless of the exclusivity of other campaigns.
        /// </summary>
        /// <value>Lists all joint categories. A campaign with a joint category is always applied regardless of the exclusivity of other campaigns.</value>
        [DataMember(Name = "joint_categories", EmitDefaultValue = true)]
        public List<string> JointCategories
        {
            get{ return _JointCategories;}
            set
            {
                _JointCategories = value;
                _flagJointCategories = true;
            }
        }
        private List<string> _JointCategories;
        private bool _flagJointCategories;

        /// <summary>
        /// Returns false as JointCategories should not be serialized given that it's read-only.
        /// </summary>
        /// <returns>false (boolean)</returns>
        public bool ShouldSerializeJointCategories()
        {
            return _flagJointCategories;
        }
        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class StackingRules {\n");
            sb.Append("  RedeemablesLimit: ").Append(RedeemablesLimit).Append("\n");
            sb.Append("  ApplicableRedeemablesLimit: ").Append(ApplicableRedeemablesLimit).Append("\n");
            sb.Append("  ApplicableRedeemablesPerCategoryLimit: ").Append(ApplicableRedeemablesPerCategoryLimit).Append("\n");
            sb.Append("  ApplicableExclusiveRedeemablesLimit: ").Append(ApplicableExclusiveRedeemablesLimit).Append("\n");
            sb.Append("  ApplicableExclusiveRedeemablesPerCategoryLimit: ").Append(ApplicableExclusiveRedeemablesPerCategoryLimit).Append("\n");
            sb.Append("  ExclusiveCategories: ").Append(ExclusiveCategories).Append("\n");
            sb.Append("  JointCategories: ").Append(JointCategories).Append("\n");
            sb.Append("  RedeemablesApplicationMode: ").Append(RedeemablesApplicationMode).Append("\n");
            sb.Append("  RedeemablesSortingRule: ").Append(RedeemablesSortingRule).Append("\n");
            sb.Append("  RedeemablesProductsApplicationMode: ").Append(RedeemablesProductsApplicationMode).Append("\n");
            sb.Append("  RedeemablesNoEffectRule: ").Append(RedeemablesNoEffectRule).Append("\n");
            sb.Append("  RedeemablesRollbackOrderMode: ").Append(RedeemablesRollbackOrderMode).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            // RedeemablesLimit (int?) maximum
            if (this.RedeemablesLimit > (int?)30)
            {
                yield return new ValidationResult("Invalid value for RedeemablesLimit, must be a value less than or equal to 30.", new [] { "RedeemablesLimit" });
            }

            // RedeemablesLimit (int?) minimum
            if (this.RedeemablesLimit < (int?)1)
            {
                yield return new ValidationResult("Invalid value for RedeemablesLimit, must be a value greater than or equal to 1.", new [] { "RedeemablesLimit" });
            }

            // ApplicableRedeemablesLimit (int?) maximum
            if (this.ApplicableRedeemablesLimit > (int?)30)
            {
                yield return new ValidationResult("Invalid value for ApplicableRedeemablesLimit, must be a value less than or equal to 30.", new [] { "ApplicableRedeemablesLimit" });
            }

            // ApplicableRedeemablesLimit (int?) minimum
            if (this.ApplicableRedeemablesLimit < (int?)1)
            {
                yield return new ValidationResult("Invalid value for ApplicableRedeemablesLimit, must be a value greater than or equal to 1.", new [] { "ApplicableRedeemablesLimit" });
            }

            // ApplicableRedeemablesPerCategoryLimit (int?) maximum
            if (this.ApplicableRedeemablesPerCategoryLimit > (int?)5)
            {
                yield return new ValidationResult("Invalid value for ApplicableRedeemablesPerCategoryLimit, must be a value less than or equal to 5.", new [] { "ApplicableRedeemablesPerCategoryLimit" });
            }

            // ApplicableRedeemablesPerCategoryLimit (int?) minimum
            if (this.ApplicableRedeemablesPerCategoryLimit < (int?)1)
            {
                yield return new ValidationResult("Invalid value for ApplicableRedeemablesPerCategoryLimit, must be a value greater than or equal to 1.", new [] { "ApplicableRedeemablesPerCategoryLimit" });
            }

            // ApplicableExclusiveRedeemablesLimit (int?) maximum
            if (this.ApplicableExclusiveRedeemablesLimit > (int?)5)
            {
                yield return new ValidationResult("Invalid value for ApplicableExclusiveRedeemablesLimit, must be a value less than or equal to 5.", new [] { "ApplicableExclusiveRedeemablesLimit" });
            }

            // ApplicableExclusiveRedeemablesLimit (int?) minimum
            if (this.ApplicableExclusiveRedeemablesLimit < (int?)1)
            {
                yield return new ValidationResult("Invalid value for ApplicableExclusiveRedeemablesLimit, must be a value greater than or equal to 1.", new [] { "ApplicableExclusiveRedeemablesLimit" });
            }

            // ApplicableExclusiveRedeemablesPerCategoryLimit (int?) maximum
            if (this.ApplicableExclusiveRedeemablesPerCategoryLimit > (int?)5)
            {
                yield return new ValidationResult("Invalid value for ApplicableExclusiveRedeemablesPerCategoryLimit, must be a value less than or equal to 5.", new [] { "ApplicableExclusiveRedeemablesPerCategoryLimit" });
            }

            // ApplicableExclusiveRedeemablesPerCategoryLimit (int?) minimum
            if (this.ApplicableExclusiveRedeemablesPerCategoryLimit < (int?)1)
            {
                yield return new ValidationResult("Invalid value for ApplicableExclusiveRedeemablesPerCategoryLimit, must be a value greater than or equal to 1.", new [] { "ApplicableExclusiveRedeemablesPerCategoryLimit" });
            }

            yield break;
        }
    }

}
