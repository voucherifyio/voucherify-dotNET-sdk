/*
 * Voucherify API
 *
 * Voucherify promotion engine REST API. Please see https://docs.voucherify.io/docs for more details.
 *
 * The version of the OpenAPI document: v2018-08-01
 * Contact: support@voucherify.io
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Runtime.Serialization;
using System.Text;
using System.Text.RegularExpressions;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Linq;
using System.ComponentModel.DataAnnotations;
using OpenAPIDateConverter = Voucherify.Client.OpenAPIDateConverter;

namespace Voucherify.Model
{
    /// <summary>
    /// ApplicableTo
    /// </summary>
    [DataContract(Name = "ApplicableTo")]
    public partial class ApplicableTo : IValidatableObject
    {
        /// <summary>
        /// This object stores information about the resource to which the discount is applicable.
        /// </summary>
        /// <value>This object stores information about the resource to which the discount is applicable.</value>
        [JsonConverter(typeof(StringEnumConverter))]
        public enum ObjectEnum
        {
            /// <summary>
            /// Enum Product for value: product
            /// </summary>
            [EnumMember(Value = "product")]
            Product = 1,

            /// <summary>
            /// Enum Sku for value: sku
            /// </summary>
            [EnumMember(Value = "sku")]
            Sku = 2,

            /// <summary>
            /// Enum ProductsCollection for value: products_collection
            /// </summary>
            [EnumMember(Value = "products_collection")]
            ProductsCollection = 3
        }


        /// <summary>
        /// This object stores information about the resource to which the discount is applicable.
        /// </summary>
        /// <value>This object stores information about the resource to which the discount is applicable.</value>

        [DataMember(Name = "object", EmitDefaultValue = true)]
        public ObjectEnum? Object
        {
            get{ return _Object;}
            set
            {
                _Object = value;
                _flagObject = true;
            }
        }
        private ObjectEnum? _Object;
        private bool _flagObject;

        /// <summary>
        /// Returns false as Object should not be serialized given that it's read-only.
        /// </summary>
        /// <returns>false (boolean)</returns>
        public bool ShouldSerializeObject()
        {
            return _flagObject;
        }

        /// <summary>
        /// Gets or Sets Effect
        /// </summary>

        [DataMember(Name = "effect", IsRequired = true, EmitDefaultValue = true)]
        public ApplicableToEffect Effect
        {
            get{ return _Effect;}
            set
            {
                _Effect = value;
                _flagEffect = true;
            }
        }
        private ApplicableToEffect _Effect;
        private bool _flagEffect;

        /// <summary>
        /// Returns false as Effect should not be serialized given that it's read-only.
        /// </summary>
        /// <returns>false (boolean)</returns>
        public bool ShouldSerializeEffect()
        {
            return _flagEffect;
        }
        /// <summary>
        /// Determines to which kinds of objects the discount is applicable. &#x60;ITEM&#x60; includes products and SKUs. &#x60;UNIT&#x60; means particular units within an order line.
        /// </summary>
        /// <value>Determines to which kinds of objects the discount is applicable. &#x60;ITEM&#x60; includes products and SKUs. &#x60;UNIT&#x60; means particular units within an order line.</value>
        [JsonConverter(typeof(StringEnumConverter))]
        public enum TargetEnum
        {
            /// <summary>
            /// Enum ITEM for value: ITEM
            /// </summary>
            [EnumMember(Value = "ITEM")]
            ITEM = 1,

            /// <summary>
            /// Enum UNIT for value: UNIT
            /// </summary>
            [EnumMember(Value = "UNIT")]
            UNIT = 2
        }


        /// <summary>
        /// Determines to which kinds of objects the discount is applicable. &#x60;ITEM&#x60; includes products and SKUs. &#x60;UNIT&#x60; means particular units within an order line.
        /// </summary>
        /// <value>Determines to which kinds of objects the discount is applicable. &#x60;ITEM&#x60; includes products and SKUs. &#x60;UNIT&#x60; means particular units within an order line.</value>

        [DataMember(Name = "target", EmitDefaultValue = true)]
        public TargetEnum? Target
        {
            get{ return _Target;}
            set
            {
                _Target = value;
                _flagTarget = true;
            }
        }
        private TargetEnum? _Target;
        private bool _flagTarget;

        /// <summary>
        /// Returns false as Target should not be serialized given that it's read-only.
        /// </summary>
        /// <returns>false (boolean)</returns>
        public bool ShouldSerializeTarget()
        {
            return _flagTarget;
        }
        /// <summary>
        /// Initializes a new instance of the <see cref="ApplicableTo" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected ApplicableTo() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="ApplicableTo" /> class.
        /// </summary>
        /// <param name="varObject">This object stores information about the resource to which the discount is applicable..</param>
        /// <param name="id">Unique product collection, product, or SKU identifier assigned by Voucherify..</param>
        /// <param name="sourceId">The source identifier from your inventory system..</param>
        /// <param name="productId">Parent product&#39;s unique ID assigned by Voucherify..</param>
        /// <param name="productSourceId">Parent product&#39;s source ID from your inventory system..</param>
        /// <param name="price">New fixed price of an item. Value is multiplied by 100 to precisely represent 2 decimal places. For example, a $10 price is written as 1000. In case of the fixed price being calculated by the formula, i.e. the price_formula parameter is present in the fixed price definition, this value becomes the fallback value. Such that in a case where the formula cannot be calculated due to missing metadata, for example, this value will be used as the fixed price..</param>
        /// <param name="priceFormula">Formula used to calculate the discounted price of an item..</param>
        /// <param name="effect">effect (required).</param>
        /// <param name="quantityLimit">The maximum number of units allowed to be discounted per order line item..</param>
        /// <param name="aggregatedQuantityLimit">The maximum number of units allowed to be discounted combined across all matched order line items..</param>
        /// <param name="amountLimit">Upper limit allowed to be applied as a discount per order line item. Value is multiplied by 100 to precisely represent 2 decimal places. For example, a $6 maximum discount is written as 600..</param>
        /// <param name="aggregatedAmountLimit">Maximum discount amount per order. Value is multiplied by 100 to precisely represent 2 decimal places. For example, a $6 maximum discount on the entire order is written as 600. This value is definable for the following discount effects: - &#x60;APPLY_TO_ITEMS&#x60; (each item subtotal is discounted equally) - &#x60;APPLY_TO_ITEMS_BY_QUANTITY&#x60; (each unit of matched products has the same discount value).</param>
        /// <param name="orderItemIndices">Lists which order lines are (not) covered by the discount. The order in the array is determined by the sequence of applied discounts, while the numbers correspond to the order lines sent in the &#x60;order&#x60; object in the request. The first order line is assigned &#x60;0&#x60;, the second order line is assigned &#x60;1&#x60;, and so on..</param>
        /// <param name="orderItemUnits">Lists which units within order lines are covered by the discount. The order line items are listed according to sequence of applied discounts while the &#x60;index&#x60; corresponds to the order line sent in the &#x60;order&#x60; object in the request..</param>
        /// <param name="repeat">Determines the recurrence of the discount, e.g. &#x60;\&quot;repeat\&quot;: 3&#x60; means that the discount is applied to every third item..</param>
        /// <param name="skipInitially">Determines how many items are skipped before the discount is applied..</param>
        /// <param name="target">Determines to which kinds of objects the discount is applicable. &#x60;ITEM&#x60; includes products and SKUs. &#x60;UNIT&#x60; means particular units within an order line..</param>
        public ApplicableTo(ObjectEnum? varObject = default(ObjectEnum?), string id = default(string), string sourceId = default(string), string productId = default(string), string productSourceId = default(string), decimal? price = default(decimal?), decimal? priceFormula = default(decimal?), ApplicableToEffect effect = default(ApplicableToEffect), int? quantityLimit = default(int?), int? aggregatedQuantityLimit = default(int?), int? amountLimit = default(int?), int? aggregatedAmountLimit = default(int?), List<int> orderItemIndices = default(List<int>), List<ApplicableToOrderItemUnitsItem> orderItemUnits = default(List<ApplicableToOrderItemUnitsItem>), int? repeat = default(int?), int? skipInitially = default(int?), TargetEnum? target = default(TargetEnum?))
        {
            this._Effect = effect;
            this._Object = varObject;
            if (this.Object != null)
            {
                this._flagObject = true;
            }
            this._Id = id;
            if (this.Id != null)
            {
                this._flagId = true;
            }
            this._SourceId = sourceId;
            if (this.SourceId != null)
            {
                this._flagSourceId = true;
            }
            this._ProductId = productId;
            if (this.ProductId != null)
            {
                this._flagProductId = true;
            }
            this._ProductSourceId = productSourceId;
            if (this.ProductSourceId != null)
            {
                this._flagProductSourceId = true;
            }
            this._Price = price;
            if (this.Price != null)
            {
                this._flagPrice = true;
            }
            this._PriceFormula = priceFormula;
            if (this.PriceFormula != null)
            {
                this._flagPriceFormula = true;
            }
            this._QuantityLimit = quantityLimit;
            if (this.QuantityLimit != null)
            {
                this._flagQuantityLimit = true;
            }
            this._AggregatedQuantityLimit = aggregatedQuantityLimit;
            if (this.AggregatedQuantityLimit != null)
            {
                this._flagAggregatedQuantityLimit = true;
            }
            this._AmountLimit = amountLimit;
            if (this.AmountLimit != null)
            {
                this._flagAmountLimit = true;
            }
            this._AggregatedAmountLimit = aggregatedAmountLimit;
            if (this.AggregatedAmountLimit != null)
            {
                this._flagAggregatedAmountLimit = true;
            }
            this._OrderItemIndices = orderItemIndices;
            if (this.OrderItemIndices != null)
            {
                this._flagOrderItemIndices = true;
            }
            this._OrderItemUnits = orderItemUnits;
            if (this.OrderItemUnits != null)
            {
                this._flagOrderItemUnits = true;
            }
            this._Repeat = repeat;
            if (this.Repeat != null)
            {
                this._flagRepeat = true;
            }
            this._SkipInitially = skipInitially;
            if (this.SkipInitially != null)
            {
                this._flagSkipInitially = true;
            }
            this._Target = target;
            if (this.Target != null)
            {
                this._flagTarget = true;
            }
        }

        /// <summary>
        /// Unique product collection, product, or SKU identifier assigned by Voucherify.
        /// </summary>
        /// <value>Unique product collection, product, or SKU identifier assigned by Voucherify.</value>
        [DataMember(Name = "id", EmitDefaultValue = true)]
        public string Id
        {
            get{ return _Id;}
            set
            {
                _Id = value;
                _flagId = true;
            }
        }
        private string _Id;
        private bool _flagId;

        /// <summary>
        /// Returns false as Id should not be serialized given that it's read-only.
        /// </summary>
        /// <returns>false (boolean)</returns>
        public bool ShouldSerializeId()
        {
            return _flagId;
        }
        /// <summary>
        /// The source identifier from your inventory system.
        /// </summary>
        /// <value>The source identifier from your inventory system.</value>
        [DataMember(Name = "source_id", EmitDefaultValue = true)]
        public string SourceId
        {
            get{ return _SourceId;}
            set
            {
                _SourceId = value;
                _flagSourceId = true;
            }
        }
        private string _SourceId;
        private bool _flagSourceId;

        /// <summary>
        /// Returns false as SourceId should not be serialized given that it's read-only.
        /// </summary>
        /// <returns>false (boolean)</returns>
        public bool ShouldSerializeSourceId()
        {
            return _flagSourceId;
        }
        /// <summary>
        /// Parent product&#39;s unique ID assigned by Voucherify.
        /// </summary>
        /// <value>Parent product&#39;s unique ID assigned by Voucherify.</value>
        [DataMember(Name = "product_id", EmitDefaultValue = true)]
        public string ProductId
        {
            get{ return _ProductId;}
            set
            {
                _ProductId = value;
                _flagProductId = true;
            }
        }
        private string _ProductId;
        private bool _flagProductId;

        /// <summary>
        /// Returns false as ProductId should not be serialized given that it's read-only.
        /// </summary>
        /// <returns>false (boolean)</returns>
        public bool ShouldSerializeProductId()
        {
            return _flagProductId;
        }
        /// <summary>
        /// Parent product&#39;s source ID from your inventory system.
        /// </summary>
        /// <value>Parent product&#39;s source ID from your inventory system.</value>
        [DataMember(Name = "product_source_id", EmitDefaultValue = true)]
        public string ProductSourceId
        {
            get{ return _ProductSourceId;}
            set
            {
                _ProductSourceId = value;
                _flagProductSourceId = true;
            }
        }
        private string _ProductSourceId;
        private bool _flagProductSourceId;

        /// <summary>
        /// Returns false as ProductSourceId should not be serialized given that it's read-only.
        /// </summary>
        /// <returns>false (boolean)</returns>
        public bool ShouldSerializeProductSourceId()
        {
            return _flagProductSourceId;
        }
        /// <summary>
        /// New fixed price of an item. Value is multiplied by 100 to precisely represent 2 decimal places. For example, a $10 price is written as 1000. In case of the fixed price being calculated by the formula, i.e. the price_formula parameter is present in the fixed price definition, this value becomes the fallback value. Such that in a case where the formula cannot be calculated due to missing metadata, for example, this value will be used as the fixed price.
        /// </summary>
        /// <value>New fixed price of an item. Value is multiplied by 100 to precisely represent 2 decimal places. For example, a $10 price is written as 1000. In case of the fixed price being calculated by the formula, i.e. the price_formula parameter is present in the fixed price definition, this value becomes the fallback value. Such that in a case where the formula cannot be calculated due to missing metadata, for example, this value will be used as the fixed price.</value>
        [DataMember(Name = "price", EmitDefaultValue = true)]
        public decimal? Price
        {
            get{ return _Price;}
            set
            {
                _Price = value;
                _flagPrice = true;
            }
        }
        private decimal? _Price;
        private bool _flagPrice;

        /// <summary>
        /// Returns false as Price should not be serialized given that it's read-only.
        /// </summary>
        /// <returns>false (boolean)</returns>
        public bool ShouldSerializePrice()
        {
            return _flagPrice;
        }
        /// <summary>
        /// Formula used to calculate the discounted price of an item.
        /// </summary>
        /// <value>Formula used to calculate the discounted price of an item.</value>
        [DataMember(Name = "price_formula", EmitDefaultValue = true)]
        public decimal? PriceFormula
        {
            get{ return _PriceFormula;}
            set
            {
                _PriceFormula = value;
                _flagPriceFormula = true;
            }
        }
        private decimal? _PriceFormula;
        private bool _flagPriceFormula;

        /// <summary>
        /// Returns false as PriceFormula should not be serialized given that it's read-only.
        /// </summary>
        /// <returns>false (boolean)</returns>
        public bool ShouldSerializePriceFormula()
        {
            return _flagPriceFormula;
        }
        /// <summary>
        /// The maximum number of units allowed to be discounted per order line item.
        /// </summary>
        /// <value>The maximum number of units allowed to be discounted per order line item.</value>
        [DataMember(Name = "quantity_limit", EmitDefaultValue = true)]
        public int? QuantityLimit
        {
            get{ return _QuantityLimit;}
            set
            {
                _QuantityLimit = value;
                _flagQuantityLimit = true;
            }
        }
        private int? _QuantityLimit;
        private bool _flagQuantityLimit;

        /// <summary>
        /// Returns false as QuantityLimit should not be serialized given that it's read-only.
        /// </summary>
        /// <returns>false (boolean)</returns>
        public bool ShouldSerializeQuantityLimit()
        {
            return _flagQuantityLimit;
        }
        /// <summary>
        /// The maximum number of units allowed to be discounted combined across all matched order line items.
        /// </summary>
        /// <value>The maximum number of units allowed to be discounted combined across all matched order line items.</value>
        [DataMember(Name = "aggregated_quantity_limit", EmitDefaultValue = true)]
        public int? AggregatedQuantityLimit
        {
            get{ return _AggregatedQuantityLimit;}
            set
            {
                _AggregatedQuantityLimit = value;
                _flagAggregatedQuantityLimit = true;
            }
        }
        private int? _AggregatedQuantityLimit;
        private bool _flagAggregatedQuantityLimit;

        /// <summary>
        /// Returns false as AggregatedQuantityLimit should not be serialized given that it's read-only.
        /// </summary>
        /// <returns>false (boolean)</returns>
        public bool ShouldSerializeAggregatedQuantityLimit()
        {
            return _flagAggregatedQuantityLimit;
        }
        /// <summary>
        /// Upper limit allowed to be applied as a discount per order line item. Value is multiplied by 100 to precisely represent 2 decimal places. For example, a $6 maximum discount is written as 600.
        /// </summary>
        /// <value>Upper limit allowed to be applied as a discount per order line item. Value is multiplied by 100 to precisely represent 2 decimal places. For example, a $6 maximum discount is written as 600.</value>
        [DataMember(Name = "amount_limit", EmitDefaultValue = true)]
        public int? AmountLimit
        {
            get{ return _AmountLimit;}
            set
            {
                _AmountLimit = value;
                _flagAmountLimit = true;
            }
        }
        private int? _AmountLimit;
        private bool _flagAmountLimit;

        /// <summary>
        /// Returns false as AmountLimit should not be serialized given that it's read-only.
        /// </summary>
        /// <returns>false (boolean)</returns>
        public bool ShouldSerializeAmountLimit()
        {
            return _flagAmountLimit;
        }
        /// <summary>
        /// Maximum discount amount per order. Value is multiplied by 100 to precisely represent 2 decimal places. For example, a $6 maximum discount on the entire order is written as 600. This value is definable for the following discount effects: - &#x60;APPLY_TO_ITEMS&#x60; (each item subtotal is discounted equally) - &#x60;APPLY_TO_ITEMS_BY_QUANTITY&#x60; (each unit of matched products has the same discount value)
        /// </summary>
        /// <value>Maximum discount amount per order. Value is multiplied by 100 to precisely represent 2 decimal places. For example, a $6 maximum discount on the entire order is written as 600. This value is definable for the following discount effects: - &#x60;APPLY_TO_ITEMS&#x60; (each item subtotal is discounted equally) - &#x60;APPLY_TO_ITEMS_BY_QUANTITY&#x60; (each unit of matched products has the same discount value)</value>
        [DataMember(Name = "aggregated_amount_limit", EmitDefaultValue = true)]
        public int? AggregatedAmountLimit
        {
            get{ return _AggregatedAmountLimit;}
            set
            {
                _AggregatedAmountLimit = value;
                _flagAggregatedAmountLimit = true;
            }
        }
        private int? _AggregatedAmountLimit;
        private bool _flagAggregatedAmountLimit;

        /// <summary>
        /// Returns false as AggregatedAmountLimit should not be serialized given that it's read-only.
        /// </summary>
        /// <returns>false (boolean)</returns>
        public bool ShouldSerializeAggregatedAmountLimit()
        {
            return _flagAggregatedAmountLimit;
        }
        /// <summary>
        /// Lists which order lines are (not) covered by the discount. The order in the array is determined by the sequence of applied discounts, while the numbers correspond to the order lines sent in the &#x60;order&#x60; object in the request. The first order line is assigned &#x60;0&#x60;, the second order line is assigned &#x60;1&#x60;, and so on.
        /// </summary>
        /// <value>Lists which order lines are (not) covered by the discount. The order in the array is determined by the sequence of applied discounts, while the numbers correspond to the order lines sent in the &#x60;order&#x60; object in the request. The first order line is assigned &#x60;0&#x60;, the second order line is assigned &#x60;1&#x60;, and so on.</value>
        [DataMember(Name = "order_item_indices", EmitDefaultValue = true)]
        public List<int> OrderItemIndices
        {
            get{ return _OrderItemIndices;}
            set
            {
                _OrderItemIndices = value;
                _flagOrderItemIndices = true;
            }
        }
        private List<int> _OrderItemIndices;
        private bool _flagOrderItemIndices;

        /// <summary>
        /// Returns false as OrderItemIndices should not be serialized given that it's read-only.
        /// </summary>
        /// <returns>false (boolean)</returns>
        public bool ShouldSerializeOrderItemIndices()
        {
            return _flagOrderItemIndices;
        }
        /// <summary>
        /// Lists which units within order lines are covered by the discount. The order line items are listed according to sequence of applied discounts while the &#x60;index&#x60; corresponds to the order line sent in the &#x60;order&#x60; object in the request.
        /// </summary>
        /// <value>Lists which units within order lines are covered by the discount. The order line items are listed according to sequence of applied discounts while the &#x60;index&#x60; corresponds to the order line sent in the &#x60;order&#x60; object in the request.</value>
        [DataMember(Name = "order_item_units", EmitDefaultValue = true)]
        public List<ApplicableToOrderItemUnitsItem> OrderItemUnits
        {
            get{ return _OrderItemUnits;}
            set
            {
                _OrderItemUnits = value;
                _flagOrderItemUnits = true;
            }
        }
        private List<ApplicableToOrderItemUnitsItem> _OrderItemUnits;
        private bool _flagOrderItemUnits;

        /// <summary>
        /// Returns false as OrderItemUnits should not be serialized given that it's read-only.
        /// </summary>
        /// <returns>false (boolean)</returns>
        public bool ShouldSerializeOrderItemUnits()
        {
            return _flagOrderItemUnits;
        }
        /// <summary>
        /// Determines the recurrence of the discount, e.g. &#x60;\&quot;repeat\&quot;: 3&#x60; means that the discount is applied to every third item.
        /// </summary>
        /// <value>Determines the recurrence of the discount, e.g. &#x60;\&quot;repeat\&quot;: 3&#x60; means that the discount is applied to every third item.</value>
        [DataMember(Name = "repeat", EmitDefaultValue = true)]
        public int? Repeat
        {
            get{ return _Repeat;}
            set
            {
                _Repeat = value;
                _flagRepeat = true;
            }
        }
        private int? _Repeat;
        private bool _flagRepeat;

        /// <summary>
        /// Returns false as Repeat should not be serialized given that it's read-only.
        /// </summary>
        /// <returns>false (boolean)</returns>
        public bool ShouldSerializeRepeat()
        {
            return _flagRepeat;
        }
        /// <summary>
        /// Determines how many items are skipped before the discount is applied.
        /// </summary>
        /// <value>Determines how many items are skipped before the discount is applied.</value>
        [DataMember(Name = "skip_initially", EmitDefaultValue = true)]
        public int? SkipInitially
        {
            get{ return _SkipInitially;}
            set
            {
                _SkipInitially = value;
                _flagSkipInitially = true;
            }
        }
        private int? _SkipInitially;
        private bool _flagSkipInitially;

        /// <summary>
        /// Returns false as SkipInitially should not be serialized given that it's read-only.
        /// </summary>
        /// <returns>false (boolean)</returns>
        public bool ShouldSerializeSkipInitially()
        {
            return _flagSkipInitially;
        }
        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class ApplicableTo {\n");
            sb.Append("  Object: ").Append(Object).Append("\n");
            sb.Append("  Id: ").Append(Id).Append("\n");
            sb.Append("  SourceId: ").Append(SourceId).Append("\n");
            sb.Append("  ProductId: ").Append(ProductId).Append("\n");
            sb.Append("  ProductSourceId: ").Append(ProductSourceId).Append("\n");
            sb.Append("  Price: ").Append(Price).Append("\n");
            sb.Append("  PriceFormula: ").Append(PriceFormula).Append("\n");
            sb.Append("  Effect: ").Append(Effect).Append("\n");
            sb.Append("  QuantityLimit: ").Append(QuantityLimit).Append("\n");
            sb.Append("  AggregatedQuantityLimit: ").Append(AggregatedQuantityLimit).Append("\n");
            sb.Append("  AmountLimit: ").Append(AmountLimit).Append("\n");
            sb.Append("  AggregatedAmountLimit: ").Append(AggregatedAmountLimit).Append("\n");
            sb.Append("  OrderItemIndices: ").Append(OrderItemIndices).Append("\n");
            sb.Append("  OrderItemUnits: ").Append(OrderItemUnits).Append("\n");
            sb.Append("  Repeat: ").Append(Repeat).Append("\n");
            sb.Append("  SkipInitially: ").Append(SkipInitially).Append("\n");
            sb.Append("  Target: ").Append(Target).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }

}
